### INFORME DE ESTADO Y PLAN DE ACCIÓN - 2025-06-10 07:36:00

**ESTADO ACTUAL:**
*   **FASE 2: HIPÓTESIS Y PLAN DE ACCIÓN UNIFICADO.** El análisis sistémico ha concluido. Se ha presentado un plan de acción y se espera aprobación para proceder a la FASE 3.

**1. OBSERVACIONES (Resultados de FASE 1):**
*   **Backend:** Funciona correctamente, sirviendo todas las solicitudes con éxito.
*   **Frontend (Logs):**
    *   Se ha identificado un error fatal de ciclo de vida (`sniffio.AsyncLibraryNotFoundError`) durante el apagado, causado por un intento de limpieza asíncrona fuera del bucle de eventos activo.
    *   Se han identificado múltiples `TypeError` y `AttributeError` durante la inicialización de `StrategiesView` en `main_window.py`, indicando que no se pasan los argumentos correctos a su constructor y se intenta conectar a un método inexistente.
    *   Se ha observado un `RuntimeError` por condición de carrera, donde tareas de actualización de datos se inician antes de que la inicialización principal de la aplicación haya terminado.
    *   **Observación Clave:** Los logs confirman que los datos del backend **SÍ LLEGAN** a los métodos manejadores en los widgets (ej. `portfolio_widget`), pero no se reflejan en la UI. Esto apunta a un fallo en el mecanismo de actualización de la UI desde el callback asíncrono.

**2. HIPÓTESIS CENTRAL (Resultados de FASE 2):**
*   La causa raíz de la "interfaz muerta" es una **implementación defectuosa del modelo de concurrencia `qasync`**. Los datos no fluyen del `ApiWorker` a la UI porque los métodos *handler* (slots) que reciben los resultados no están correctamente diseñados para interactuar con los widgets de Qt desde un hilo asíncrono. Deben ser decorados como `@qasync.asyncSlot` o, si son síncronos, deben ser llamados de una manera segura para el hilo (`thread-safe`). Este problema fundamental de arquitectura es la causa del no renderizado de datos. Los otros errores (`TypeError`, `AttributeError`, `sniffio`) son fallos de programación secundarios pero críticos que contribuyen a la inestabilidad general.

**3. PLAN DE ACCIÓN UNIFICADO (Propuesta para FASE 3):**
| Archivo a Modificar                                     | Descripción del Cambio                                                                                                                                                                                          | Justificación (Por qué este cambio soluciona el problema)                                                                                                                                                           |
| :------------------------------------------------------ | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `src/ultibot_ui/views/portfolio_view.py`                | 1. Identificar el método que recibe los datos del `ApiWorker` (ej. `_handle_portfolio_result`).<br>2. Asegurar que esté decorado con `@qasync.asyncSlot`.<br>3. Dentro del método, ejecutar la lógica que actualiza la UI. | El decorador `@qasync.asyncSlot` es la forma canónica en `qasync` para permitir que una corutina interactúe de forma segura con los componentes de la UI de Qt, resolviendo el problema de renderizado.             |
| `src/ultibot_ui/views/opportunities_view.py`            | Aplicar la misma corrección que en `portfolio_view.py` al método `_handle_opportunities_result`.                                                                                                                | Se aplica el mismo principio arquitectónico para garantizar la actualización segura de la UI en esta vista.                                                                                                     |
| `src/ultibot_ui/widgets/chart_widget.py`                | Aplicar la misma corrección a los métodos que reciben datos de OHLCV.                                                                                                                                           | Se aplica el mismo principio arquitectónico para garantizar la actualización segura de la UI en este widget.                                                                                                    |
| `src/ultibot_ui/views/strategies_view.py`               | 1. Corregir el `AttributeError` implementando el método `update_strategies(self, strategies)` que faltaba.<br>2. Decorar el nuevo método con `@qasync.asyncSlot`.                                                  | Se corrige el error de arranque y se implementa el patrón correcto de actualización asíncrona de la UI.                                                                                                         |
| `src/ultibot_ui/widgets/paper_trading_report_widget.py` | Aplicar la misma corrección a los métodos `_on_metrics_received` y `_on_trades_received`.                                                                                                                       | Se aplica el mismo principio arquitectónico para garantizar la actualización segura de la UI en este widget.                                                                                                    |
| `src/ultibot_ui/windows/main_window.py`                 | Corregir el `TypeError` pasando los argumentos requeridos (`user_id`, `api_client`, etc.) al constructor de `StrategiesView` durante su instanciación.                                                            | Resuelve el error de inicialización que impedía que la vista de estrategias se cargara.                                                                                                                           |
| `src/ultibot_ui/main.py`                                | Refactorizar la gestión del ciclo de vida. La limpieza (`controller.cleanup()`) debe engancharse a la señal `app.aboutToQuit` usando un `slot` asíncrono para resolver el error de `sniffio`.                     | Esto asegura que la limpieza asíncrona se ejecute dentro del bucle de eventos activo, eliminando el error de apagado y estabilizando el ciclo de vida de la aplicación.                                           |

**4. RIESGOS POTENCIALES:**
*   La modificación de los manejadores de datos podría introducir nuevas condiciones de carrera si no se gestiona el estado (ej. deshabilitar un botón de "refrescar" mientras una actualización está en curso). Sin embargo, el riesgo es bajo, ya que el plan se enfoca en aplicar un patrón de diseño estándar y probado para `qasync`.

**5. SOLICITUD:**
*   **[PAUSA]** Espero aprobación para proceder con la ejecución de este plan de acción unificado y de raíz.
