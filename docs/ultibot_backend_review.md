# Revisión del Backend de UltiBotInversiones

Este documento contiene un registro de los problemas identificados, soluciones propuestas y mejoras sugeridas durante la revisión del código del backend de UltiBotInversiones, centrándose en el pipeline de análisis de IA, el proceso de ejecución de trading real y la lógica de trading simulado y real.

## Problemas y Mejoras

## 1. Pipeline de Análisis de IA (`ai_orchestrator_service.py`)

### Problemas Identificados:

1.  **Inicialización Asíncrona de Herramientas MCP:** El método `_load_mcp_tools` es asíncrono, pero no se llama explícitamente en el `__init__` del `AIOrchestratorService`. Se menciona la necesidad de un `async_init` o cargar bajo demanda, pero la implementación actual en `main.py` inicializa el servicio sin llamar a un método asíncrono posterior para cargar las herramientas. Esto significa que `self.mcp_tools` podría estar vacío cuando se intente usar `get_available_mcp_tools` o cuando el agente intente usar las herramientas.
    *   **Impacto:** Las herramientas MCP no estarán disponibles para el agente de IA, limitando su capacidad para obtener datos externos y realizar análisis completos.
    *   **Solución/Mejora:** Implementar un método `async_init` en `AIOrchestratorService` que sea llamado después de la instanciación en `main.py` (posiblemente en el evento `startup`). Asegurar que este método cargue las herramientas MCP de forma asíncrona.

2.  **Manejo de `user_id` en `_load_mcp_tools`:** El método `_load_mcp_tools` recibe un `user_id` opcional, pero la lógica para obtener la configuración del usuario (`self.config_service.get_user_configuration(user_id=user_id)`) depende de cómo `ConfigService` maneje el `user_id` actual. Si `AIOrchestratorService` es una instancia global (como parece ser en `main.py`), necesitará gestionar explícitamente el contexto del usuario para cargar las herramientas correctas.
    *   **Impacto:** Si la instancia de `AIOrchestratorService` es compartida entre usuarios (aunque la v1.0 usa un `FIXED_USER_ID`), las herramientas MCP cargadas podrían no corresponder a la configuración del usuario que activó la señal. Incluso con un `FIXED_USER_ID`, la carga inicial podría no usar ese ID si no se pasa correctamente.
    *   **Solución/Mejora:** Asegurar que `AIOrchestratorService` se inicialice o configure con el `user_id` correcto antes de procesar señales o cargar herramientas. Si es una instancia global, cada método que dependa de la configuración del usuario (como `process_mcp_signal` y `analyze_opportunity_with_ai`) debe obtener la configuración usando el `user_id` proporcionado en la llamada al método.

3.  **Manejo de Errores al Parsear `source_data`:** En `analyze_opportunity_with_ai`, si `opportunity.source_data` no es un JSON válido, se registra un error y se eleva un `AIAnalysisError`. Sin embargo, la oportunidad se marca como `AI_ANALYSIS_FAILED` *después* de este bloque `try...except`, lo que significa que si el error ocurre, el estado de la oportunidad no se actualizará correctamente en la base de datos.
    *   **Impacto:** Las oportunidades con `source_data` inválido podrían quedarse atascadas en el estado `AI_ANALYSIS_IN_PROGRESS` o no tener un estado de fallo claro.
    *   **Solución/Mejora:** Mover la actualización del estado de la oportunidad a `AI_ANALYSIS_FAILED` y el registro del error *dentro* del bloque `except json.JSONDecodeError` o asegurar que el bloque `finally` (si existiera) o el manejo de errores posterior capture este caso y actualice el estado.

4.  **Manejo de Salida No JSON del LLM:** El código intenta parsear la salida del LLM como JSON. Si falla (`json.JSONDecodeError`), registra una advertencia pero continúa, dejando `suggested_action` y `calculated_confidence` como `None`. El `reasoning_ai` se establece al `raw_output`.
    *   **Impacto:** Si el LLM no devuelve JSON (ya sea por un error o por diseño del prompt/modelo), la oportunidad no tendrá una acción sugerida o confianza numérica, lo que impedirá que progrese a las siguientes etapas (verificación de datos, confirmación del usuario, ejecución).
    *   **Solución/Mejora:** Considerar implementar un parser de texto más robusto (quizás usando regex o incluso otro LLM call) para intentar extraer la acción sugerida y la confianza de la salida de texto plano si el parseo JSON falla. Alternativamente, documentar claramente que la salida JSON es un requisito estricto del prompt.

5.  **Dependencia de `opportunity.symbol` para Verificación de Datos:** La verificación de datos en `analyze_opportunity_with_ai` depende de `opportunity.symbol`. Si este campo es `None`, intenta obtenerlo de `source_data`. Si tampoco está ahí, marca la oportunidad como `AI_ANALYSIS_FAILED`.
    *   **Impacto:** Las oportunidades que no tengan el símbolo en el campo `symbol` o en el `source_data` (con nombres de campo esperados como "symbol" o "asset") no podrán ser verificadas y fallarán el análisis.
    *   **Solución/Mejora:** Asegurar que los adaptadores MCP que generan oportunidades incluyan el símbolo en el campo `symbol` de la entidad `Opportunity`. Mejorar la lógica de extracción del símbolo de `source_data` para ser más flexible con posibles nombres de campo o estructuras anidadas.

6.  **Lógica de Verificación de Datos (Subtask 2.3):** La lógica de comparación de precios y volumen está implementada, pero hay algunos puntos a considerar:
    *   La comparación de precios asume que tanto Mobula como Binance devuelven precios en la misma moneda de cotización (ej. USDT). Esto puede no ser siempre cierto dependiendo del activo y el par.
    *   La verificación de volumen solo usa el volumen de Binance (`quoteVolume`). Podría ser útil considerar también el volumen de Mobula si está disponible y es relevante.
    *   Si no se pueden obtener datos de Mobula o Binance, la verificación de precios se marca como "warning" pero `data_verified_successfully` no se establece a `False`. Esto podría permitir que oportunidades con datos faltantes pasen la verificación si otras comprobaciones pasan.
    *   **Impacto:** Posibles comparaciones de datos incorrectas o incompletas que podrían llevar a validar oportunidades basadas en datos no fiables.
    *   **Solución/Mejora:** Añadir lógica para normalizar las monedas de cotización antes de comparar precios. Considerar la verificación de volumen de Mobula. Decidir si la falta de datos de una fuente debe ser un fallo duro en la verificación de datos.

7.  **Actualización de `ai_analysis` en `persistence_service`:** El código convierte el objeto `AIAnalysis` a JSON string (`opportunity.ai_analysis.model_dump_json()`) antes de pasarlo a `persistence_service.update_opportunity_analysis`. Esto es correcto si el método de persistencia espera un string JSON. Confirmar que `update_opportunity_analysis` en `persistence_service.py` maneja correctamente este campo como JSONB en la base de datos.
    *   **Impacto:** Si el tipo de dato en la base de datos o la lógica de persistencia no coincide con el formato JSON string, los datos de análisis de IA podrían no guardarse correctamente.
    *   **Solución/Mejora:** Verificar la implementación de `update_opportunity_analysis` en `persistence_service.py` y el esquema de la tabla `opportunities` para asegurar que el campo `ai_analysis` se maneje como JSONB y que la conversión sea correcta.

8.  **Notificación de Alta Confianza (Subtask 3.3):** La lógica para enviar la notificación de alta confianza verifica si el estado final es `AI_ANALYSIS_COMPLETE` y si la confianza supera el umbral de Paper Trading. Sin embargo, la verificación del umbral se repite aquí después de haberse hecho para decidir si se procedía con la verificación de datos. Además, la lógica de notificación asume que `NotificationService.send_notification` maneja internamente las preferencias del usuario para enviar a UI y/o Telegram, pero el código llama explícitamente a `send_notification` dos veces (una para "ui" y otra para "telegram").
    *   **Impacto:** Posible lógica redundante en la verificación del umbral. Las notificaciones se enviarán a ambos canales independientemente de las preferencias específicas del usuario configuradas en `UserConfiguration.notificationPreferences`, siempre que `enableTelegramNotifications` sea True para Telegram.
    *   **Solución/Mejora:** Refactorizar la verificación del umbral para evitar la duplicación. Ajustar la lógica de notificación para que `send_notification` en `NotificationService` reciba el `user_id` y consulte las preferencias de notificación del usuario (`UserConfiguration.notificationPreferences`) para determinar a qué canales enviar, en lugar de llamarlo explícitamente por cada canal en `AIOrchestratorService`. Asegurar que `NotificationService` pueda acceder a `ConfigService` para obtener estas preferencias.

## 2. Proceso de Ejecución de Trading Real (`trading_engine_service.py`, `order_execution_service.py`, `credential_service.py`)

### Problemas Identificados:

1.  **Inicialización del Monitor de Trading Real:** Similar al monitor de Paper Trading, el monitor de Real Trading (`_run_real_trading_monitor_loop`) se inicia con `start_real_trading_monitor`, pero no hay una llamada explícita a este método en el evento `startup` de `main.py`. Aunque el monitor de Paper Trading se inicia, el de Real Trading parece no estar activo por defecto.
    *   **Impacto:** Los trades reales ejecutados (si se llegaran a enviar) no serían monitoreados para cierres automáticos (TSL/TP) a menos que el monitor se inicie manualmente.
    *   **Solución/Mejora:** Añadir una llamada a `trading_engine_service.start_real_trading_monitor()` en el evento `startup` de `main.py`, posiblemente condicionado a si el modo de trading real está activo en la configuración inicial del usuario.

2.  **Obtención de Credenciales en el Bucle del Monitor Real:** El monitor de Real Trading (`_run_real_trading_monitor_loop`) obtiene las credenciales de Binance *una vez por ciclo de monitoreo* usando un `FIXED_USER_ID`. Si la aplicación soportara múltiples usuarios simultáneamente, esto sería incorrecto, ya que usaría las credenciales de un usuario fijo para monitorear trades de *todos* los usuarios.
    *   **Impacto:** En una aplicación multi-usuario, el monitoreo de trades reales no funcionaría correctamente. Incluso con un `FIXED_USER_ID`, obtener las credenciales en cada ciclo puede ser ineficiente si el ciclo es muy rápido.
    *   **Solución/Mejora:** Si la aplicación sigue siendo para un solo usuario (v1.0 local), la lógica actual es aceptable, aunque obtener las credenciales fuera del bucle y manejarlas como una dependencia del servicio podría ser más limpio. Para una aplicación multi-usuario, el monitor debería iterar sobre los usuarios con trades reales abiertos y obtener las credenciales *por usuario* dentro del bucle.

3.  **Manejo de Errores de Desencriptación en el Monitor Real:** Si la desencriptación de la API Key o Secret de Binance falla dentro del bucle del monitor real, se registra un error y se salta el ciclo actual (`continue`).
    *   **Impacto:** Los trades reales de un usuario cuyas credenciales no se puedan desencriptar dejarán de ser monitoreados sin una notificación clara al usuario o un mecanismo de reintento más robusto.
    *   **Solución/Mejora:** Implementar un manejo de errores más sofisticado. Notificar al usuario sobre el fallo de desencriptación de credenciales. Considerar un mecanismo de reintento con backoff o un estado de error para las credenciales que impida intentar usarlas repetidamente si fallan.

4.  **Monitoreo de TSL/TP Basado en Precio vs. Órdenes OCO:** El método `monitor_and_manage_real_trade_exit` parece duplicar parte de la lógica de monitoreo de TSL/TP que ya debería estar cubierta por el monitoreo de órdenes OCO en `_monitor_binance_oco_orders`. Si se envían órdenes OCO al abrir un trade real, el monitor principal debería centrarse en el estado de esas órdenes OCO en Binance, no en el precio de mercado actual para ajustar un TSL local.
    *   **Impacto:** Lógica de monitoreo redundante y potencialmente conflictiva. Si se usan órdenes OCO, la lógica de ajuste de TSL basada en precio en `monitor_and_manage_real_trade_exit` es innecesaria y podría llevar a confusión o errores.
    *   **Solución/Mejora:** Clarificar la estrategia de salida para trades reales. Si se usan órdenes OCO, el monitor debe centrarse *únicamente* en el estado de esas órdenes en Binance. Si no se usan OCOs (ej. para un cierre manual o una estrategia diferente), entonces la lógica de monitoreo de precio y ajuste de TSL local sería relevante. Asegurar que solo una estrategia de monitoreo de salida esté activa por trade.

5.  **Creación de Órdenes OCO en `execute_real_trade`:** El método `create_oco_order` en `BinanceAdapter` se llama con `stopLimitPrice` calculado como `current_stop_price_tsl * (0.99)` o `* (1.01)`. Esto es una práctica común para asegurar que la orden límite de stop-loss se ejecute incluso si el precio se mueve rápidamente después de alcanzar el `stopPrice`. Sin embargo, el factor (0.99/1.01) es fijo. La precisión y el deslizamiento aceptable pueden depender del símbolo y la volatilidad.
    *   **Impacto:** El precio límite de stop-loss podría ser demasiado ajustado o demasiado amplio dependiendo del activo, afectando la ejecución.
    *   **Solución/Mejora:** Considerar hacer el factor de deslizamiento del precio límite de stop-loss configurable por el usuario o ajustarlo dinámicamente basado en la volatilidad del símbolo. Obtener la precisión del precio del `exchangeInfo` de Binance para redondear correctamente los precios de TP y SL.

6.  **Manejo de Errores al Enviar Órdenes OCO:** Si falla el envío de órdenes OCO en `execute_real_trade`, se registra un error y se envía una notificación, pero la excepción *no* se eleva (`raise`).
    *   **Impacto:** El trade real de entrada podría ejecutarse correctamente, pero las órdenes de salida (TSL/TP) no se colocarían en Binance. El trade quedaría abierto sin protección automática, y el sistema no tendría un mecanismo para cerrarlo automáticamente a menos que se implemente un monitoreo de precio alternativo (ver punto 4).
    *   **Solución/Mejora:** Decidir si la falla al colocar las órdenes OCO debe considerarse un fallo crítico de la ejecución del trade. Si es así, se debería elevar la excepción después de registrar el error y notificar. Si no es crítico (ej. se espera que el usuario gestione manualmente las salidas), documentar claramente este comportamiento y asegurar que el monitoreo de trades sin OCOs esté activo y funcione correctamente.

7.  **Actualización del Contador de Trades Reales y Capital Arriesgado:** En `execute_real_trade`, el contador `real_trades_executed_count` y `daily_capital_risked_usd` se incrementan *después* de enviar la orden de entrada y las órdenes OCO, pero *antes* de que se confirme que la orden de entrada ha sido FILLED por Binance. Si la orden de entrada falla después de ser enviada (ej. rechazada por Binance), el contador y el capital arriesgado ya se habrían incrementado incorrectamente.
    *   **Impacto:** El contador de trades reales y el capital arriesgado diario podrían ser inexactos, afectando la lógica de límites de trading real.
    *   **Solución/Mejora:** Mover la lógica de incremento del contador y actualización del capital arriesgado a un punto donde se confirme que la orden de entrada ha sido FILLED. Esto podría requerir monitorear el estado de la orden de entrada después de enviarla o manejarlo en el proceso de monitoreo de trades abiertos.

8.  **Cálculo de P&L en `_close_real_trade`:** El cálculo del P&L en `_close_real_trade` utiliza el `executedQuantity` y `executedPrice` de la orden de entrada (`trade.entryOrder`) y la orden de salida (`exit_order_details`). Esto es correcto para un cierre completo. Sin embargo, no considera posibles comisiones pagadas en las operaciones de entrada y salida, lo que afectaría el P&L neto.
    *   **Impacto:** El P&L calculado sería bruto, sin tener en cuenta las comisiones, lo que resultaría en una métrica de rendimiento inexacta.
    *   **Solución/Mejora:** Incluir las comisiones pagadas en las órdenes de entrada y salida en el cálculo del P&L neto. Las comisiones están disponibles en el campo `commissions` (o los campos legados `commission`/`commissionAsset`) de `TradeOrderDetails`.

9.  **Actualización del Portafolio Real tras Cierre:** El método `update_real_portfolio_after_exit` en `PortfolioService` simplemente registra un mensaje indicando que se debe re-consultar el balance de Binance. No actualiza ningún estado interno del portafolio real porque se asume que siempre se consulta el estado actual de Binance.
    *   **Impacto:** Aunque la lógica es conceptualmente correcta (siempre se consulta la fuente de verdad), no hay un mecanismo explícito para *gatillar* una re-consulta o una actualización de la caché del portafolio real después de un cierre. La UI o cualquier otro componente que muestre el portafolio podría mostrar datos desactualizados hasta la próxima consulta manual o programada.
    *   **Solución/Mejora:** Considerar añadir un mecanismo para invalidar la caché del portafolio real o emitir un evento que indique que el portafolio real ha cambiado y debe ser re-consultado por los componentes interesados.

10. **Dependencia Circular en `get_notification_service` en Endpoints:** En `api/v1/endpoints/notifications.py` y `api/v1/endpoints/telegram_status.py`, la función de dependencia `get_notification_service` intenta importar `CredentialService` y `SupabasePersistenceService` y crear una *nueva* instancia de `NotificationService`. Sin embargo, `main.py` ya inicializa una instancia global de `NotificationService` con las dependencias correctas. La dependencia en `main.py` para `get_notification_service` también parece incorrecta, ya que intenta importar `notification_service` globalmente.
    *   **Impacto:** Se podrían crear múltiples instancias de `NotificationService` con sus propias dependencias, lo cual es ineficiente y podría llevar a comportamientos inesperados (ej. si las instancias tienen estado). La dependencia en `main.py` para `get_notification_service` es una importación circular.
    *   **Solución/Mejora:** Refactorizar las funciones de dependencia en los endpoints para que dependan de las funciones `get_..._service` definidas en `main.py` que devuelven las instancias globales inicializadas durante el startup. Eliminar la lógica de creación de nuevas instancias de servicios dentro de las funciones de dependencia de los endpoints. Corregir la función `get_notification_service` en `main.py` para que devuelva la instancia global `notification_service` directamente.

## 3. Lógica de Trading (Paper y Real)

### Problemas Identificados:

1.  **Simulación de Órdenes de Mercado en Paper Trading (`PaperOrderExecutionService`):** La simulación de órdenes de mercado en `execute_market_order` de `PaperOrderExecutionService` utiliza un precio fijo (`simulated_price = 30000.0`) o basado en una simple comprobación de símbolo (`if "ETH" in symbol:`). Esto no refleja precios de mercado reales o recientes.
    *   **Impacto:** Las simulaciones de paper trading no serán realistas, ya que las operaciones se ejecutarán a precios estáticos en lugar de precios de mercado dinámicos.
    *   **Solución/Mejora:** Inyectar `MarketDataService` en `PaperOrderExecutionService` y usar `get_latest_price` para obtener el precio de mercado actual al simular una orden. Esto hará que las simulaciones sean mucho más realistas.

2.  **Cálculo de Cantidad en Paper Trading (`simulate_paper_entry_order`):** El cálculo de la cantidad a operar en paper trading se basa en un porcentaje del `available_capital` del portafolio de paper trading (`capital_to_invest = available_capital * per_trade_risk_percentage`). Sin embargo, `available_capital` se obtiene del `PortfolioSnapshot`, que para paper trading, en la implementación actual de `PortfolioService`, solo parece reflejar el `defaultPaperTradingCapital` inicial y las actualizaciones manuales, no el valor actual de los activos simulados.
    *   **Impacto:** El cálculo del tamaño de la posición en paper trading podría ser incorrecto, ya que no considera el valor actual de las posiciones abiertas simuladas.
    *   **Solución/Mejora:** Asegurar que `PortfolioService` mantenga y calcule correctamente el `available_balance_usdt` para paper trading, teniendo en cuenta el valor de mercado actual de los activos simulados. Esto requeriría que `PortfolioService` use `MarketDataService` para valorar los activos simulados y actualizar el saldo disponible dinámicamente.

3.  **Gestión de Capital Diario en Trading Real (`execute_real_trade`):** La lógica para el límite de capital diario arriesgado (`daily_capital_risked_usd`) se basa en un reinicio diario simple y suma el `capital_to_invest_per_trade` a este contador. Sin embargo, `capital_to_invest_per_trade` se calcula como un porcentaje del `available_capital` (saldo de USDT disponible), no necesariamente el capital *realmente* arriesgado en términos de la posible pérdida máxima (basada en el stop loss).
    *   **Impacto:** El contador `daily_capital_risked_usd` no reflejaría con precisión el riesgo real asumido, lo que podría llevar a exceder los límites de riesgo deseados o a infrautilizar el capital.
    *   **Solución/Mejora:** Ajustar la lógica de gestión de capital diario para que se base en el riesgo definido por operación (ej. la diferencia entre el precio de entrada y el stop loss, multiplicada por la cantidad), en lugar del capital invertido. Esto requeriría calcular el riesgo en USD por operación y sumarlo al contador diario.

4.  **Cálculo de TSL/TP en Paper y Real Trading (`simulate_paper_entry_order`, `execute_real_trade`):** Los niveles iniciales de Take Profit y Trailing Stop Loss se calculan correctamente basándose en porcentajes de la configuración del usuario y el precio de entrada. Sin embargo, no se considera la precisión mínima de precio y cantidad requerida por Binance para el símbolo específico.
    *   **Impacto:** Los precios de TP y TSL calculados podrían no ser válidos en Binance debido a restricciones de precisión, lo que podría causar errores al intentar colocar órdenes reales o simular cierres en paper trading.
    *   **Solución/Mejora:** Obtener la información de `exchangeInfo` de Binance (posiblemente a través de `MarketDataService` o `BinanceAdapter`) para el símbolo operado y redondear los precios de TP y TSL, así como la cantidad, a la precisión requerida antes de usarlos.

5.  **Actualización del Portafolio de Paper Trading tras Cierre (`update_paper_portfolio_after_exit`):** La lógica para actualizar el portafolio de paper trading después de un cierre (`update_paper_portfolio_after_exit` en `PortfolioService`) ajusta el `paper_trading_balance` sumando el `pnl_usd` del trade cerrado. Para posiciones largas (BUY), intenta eliminar el activo si la cantidad coincide. Para posiciones cortas (SELL), resta la cantidad. Esto es una simplificación.
    *   **Impacto:** La gestión de activos en paper trading para posiciones cortas no es precisa. Si se cierran parcialmente posiciones, la lógica actual podría no manejarlo correctamente. La persistencia de los `assetHoldings` de paper trading aún está pendiente ("TODO").
    *   **Solución/Mejora:** Implementar una gestión más robusta de posiciones cortas en paper trading. Completar la implementación de la persistencia de los `assetHoldings` del portafolio de paper trading para que el estado del portafolio simulado sea persistente entre sesiones.

6.  **Cálculo de P&L en Paper Trading (`update_paper_portfolio_after_exit`):** El cálculo del P&L en paper trading se realiza en `TradingEngineService` (`_close_paper_trade`) y se basa en la diferencia entre el precio de entrada y el precio de salida simulado. Este P&L se pasa luego a `PortfolioService` para actualizar el balance. Similar al trading real, no se consideran comisiones simuladas.
    *   **Impacto:** El P&L simulado no incluiría el impacto de las comisiones, lo que lo haría menos realista.
    *   **Solución/Mejora:** Añadir una simulación de comisiones en `PaperOrderExecutionService` al "ejecutar" órdenes y incluir estas comisiones en el cálculo del P&L en `TradingEngineService` antes de actualizar el balance en `PortfolioService`.

7.  **Monitoreo de TSL en Paper Trading (`monitor_and_manage_paper_trade_exit`):** La lógica para ajustar el TSL en paper trading se basa en el `current_price` obtenido de `MarketDataService`. El TSL se ajusta si el precio se mueve favorablemente. Sin embargo, no hay una simulación de la ejecución de la orden de stop loss si el precio alcanza el `currentStopPrice_tsl`.
    *   **Impacto:** El TSL se ajustará visualmente, pero la posición simulada no se cerrará automáticamente cuando el precio cruce el TSL. La detección de cierre por TSL/TP se menciona en los comentarios (Subtask 1.7) pero la lógica de ejecución del cierre simulado (Subtask 1.8) no está completamente clara en este método.
    *   **Solución/Mejora:** Implementar la lógica para detectar si el `current_price` cruza el `currentStopPrice_tsl` (o `takeProfitPrice`) y, si es así, llamar a un método para simular el cierre de la posición en paper trading, similar a cómo se maneja el cierre en `_close_real_trade` pero utilizando `PaperOrderExecutionService`.

8.  **Dependencia de `FIXED_USER_ID` en Varios Servicios:** Varios servicios (`TradingEngineService`, `PortfolioService`, `NotificationService`) y endpoints (`api/v1/endpoints/`) dependen directa o indirectamente de un `FIXED_USER_ID`. Aunque esto es aceptable para una v1.0 local de un solo usuario, limita la escalabilidad y la capacidad de soportar múltiples usuarios en el futuro.
    *   **Impacto:** La arquitectura actual no es adecuada para un entorno multi-usuario.
    *   **Solución/Mejora:** Refactorizar los servicios para que sean agnósticos al usuario y requieran que el `user_id` se pase como parámetro en cada método relevante. Implementar un sistema de manejo de contexto de usuario (ej. a través de dependencias en FastAPI) para que el `user_id` del usuario autenticado esté disponible para los servicios que lo necesiten.

