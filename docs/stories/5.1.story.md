# Story 5.1: Definición y Configuración Modular de Estrategias de Trading

## Status: Aprobado

## Story

- As a usuario de UltiBotInversiones
- I want que el sistema permita la definición modular de diferentes estrategias de trading (inicialmente Scalping, Day Trading, Arbitraje Simple), incluyendo sus parámetros configurables específicos
- so that puedan ser gestionadas y ejecutadas de forma independiente.

## Acceptance Criteria (ACs)

1.  El sistema debe contar con una estructura interna (ej. clases base, interfaces) que permita definir nuevas estrategias de trading de forma modular, especificando su lógica de entrada, salida y gestión de riesgos básicos.
2.  Para cada una de las estrategias base (Scalping, Day Trading, Arbitraje Simple), se deben identificar y definir sus parámetros configurables clave (ej. para Scalping: % de ganancia objetivo por operación, % de stop-loss; para Day Trading: indicadores técnicos y umbrales; para Arbitraje: umbral de diferencia de precios).
3.  El sistema debe permitir persistir la configuración de los parámetros para cada estrategia definida (utilizando la base de la Historia 1.4: Configuración Inicial de la Aplicación y Persistencia de Datos Fundamentales).
4.  La lógica de cada estrategia debe ser encapsulada de manera que pueda ser invocada por el motor de trading del sistema.
5.  La documentación interna (a nivel de código y diseño) debe describir claramente cómo añadir nuevas estrategias modulares al sistema en el futuro.

## Tasks / Subtasks

-   [ ] Task 1: Definir modelos de datos para `TradingStrategyConfig` y parámetros específicos de estrategias (AC: 1, 2)
    -   [ ] Subtask 1.1: Crear `src/ultibot_backend/core/domain_models/trading_strategy_models.py` con `TradingStrategyConfig` y las interfaces/clases para `ScalpingParameters`, `DayTradingParameters`, `ArbitrageSimpleParameters`, etc., utilizando Pydantic.
    -   [ ] Subtask 1.2: Asegurar que `BaseStrategyType` sea un `Enum` de Python.
-   [ ] Task 2: Implementar el servicio `StrategyService` para la gestión de configuraciones (AC: 3, 4)
    -   [ ] Subtask 2.1: Crear `src/ultibot_backend/services/strategy_service.py` con una clase `StrategyService`.
    -   [ ] Subtask 2.2: Implementar métodos en `StrategyService` para crear, leer, actualizar y eliminar configuraciones de estrategias, interactuando con `DataPersistenceService`.
    -   [ ] Subtask 2.3: Implementar métodos para activar/desactivar estrategias en modos Paper/Real.
    -   [ ] Subtask 2.4: Asegurar que la lógica de persistencia utilice la base de la Historia 1.4 (Supabase/PostgreSQL).
-   [ ] Task 3: Crear endpoints de API para la gestión de estrategias (AC: 3)
    -   [ ] Subtask 3.1: Crear `src/ultibot_backend/api/v1/endpoints/strategies.py` con un `APIRouter`.
    -   [ ] Subtask 3.2: Implementar endpoints para `POST /strategies` (crear), `GET /strategies` (listar), `GET /strategies/{id}` (obtener por ID), `PUT /strategies/{id}` (actualizar), `DELETE /strategies/{id}` (eliminar).
    -   [ ] Subtask 3.3: Implementar endpoints para `PATCH /strategies/{id}/activate` y `PATCH /strategies/{id}/deactivate` para modos Paper/Real.
    -   [ ] Subtask 3.4: Utilizar modelos Pydantic para la validación de request/response bodies (ej. `SaveTradingStrategyConfigRequest`).
-   [ ] Task 4: Actualizar la documentación interna (AC: 5)
    -   [ ] Subtask 4.1: Añadir/actualizar docstrings en los nuevos módulos y clases (`trading_strategy_models.py`, `strategy_service.py`, `strategies.py`).
    -   [ ] Subtask 4.2: Actualizar `docs/Architecture.md` y `docs/data-models.md` con referencias a los nuevos componentes y modelos.
    -   [ ] Subtask 4.3: Añadir una sección en `docs/operational-guidelines.md` o un nuevo documento si es necesario, explicando cómo añadir nuevas estrategias modulares.

## Dev Technical Guidance

-   **Modelos de Datos:**
    -   Utilizar Pydantic para definir `TradingStrategyConfig` y las interfaces de parámetros específicos.
    -   Asegurar que los campos `parameters`, `applicabilityRules`, `riskParametersOverride`, `marketConditionFilters`, `activationSchedule`, `dependsOnStrategies`, `sharingMetadata` sean `JSONB` en la base de datos, lo que se mapeará a `dict` o Pydantic models en Python.
    -   El `id` de `aiAnalysisProfileId` en `TradingStrategyConfig` debe hacer referencia a un `id` dentro de `UserConfiguration.aiStrategyConfigurations`.
    -   El `exchangeA_credentialLabel` y `exchangeB_credentialLabel` en `ArbitrageSimpleParameters` deben hacer referencia a `APICredential.credentialLabel`.
-   **Servicio de Estrategias (`StrategyService`):**
    -   Debe ser un servicio inyectable en FastAPI.
    -   Debe interactuar con `DataPersistenceService` para operaciones CRUD en la tabla `trading_strategy_configs`.
    -   La activación/desactivación debe actualizar los campos `is_active_paper_mode` y `is_active_real_mode` en la base de datos.
    -   Considerar la validación de los parámetros de la estrategia al guardarlos.
-   **Endpoints de API (`strategies.py`):**
    -   Seguir las convenciones de FastAPI para routers y modelos de respuesta.
    -   Implementar la inyección de dependencias para `StrategyService`.
    -   Asegurar el manejo de errores apropiado (ej. `HTTPException` para estrategia no encontrada, parámetros inválidos).
    -   La creación (`POST`) debe generar un UUID para el `id` de la nueva configuración.
-   **Estructura de Archivos:**
    -   `src/ultibot_backend/core/domain_models/trading_strategy_models.py` para los modelos Pydantic.
    -   `src/ultibot_backend/services/strategy_service.py` para la lógica de negocio.
    -   `src/ultibot_backend/api/v1/endpoints/strategies.py` para los endpoints de la API.
    -   Asegurar que los `__init__.py` estén actualizados para que los módulos sean importables.
-   **Pruebas:**
    -   Crear pruebas unitarias para `StrategyService` (mockeando `DataPersistenceService`).
    -   Crear pruebas de integración para los endpoints de la API (mockeando `StrategyService`).
    -   Asegurar la cobertura de casos de éxito, errores de validación y casos límite para los parámetros de las estrategias.
-   **Consideraciones de Seguridad:**
    -   Asegurar que no se expongan datos sensibles (como API keys) en los parámetros de las estrategias; en su lugar, usar referencias a `APICredential.id` o `credentialLabel`.
    -   La validación de entrada debe ser estricta.
-   **Principios de Diseño:**
    -   Adherirse a SRP: cada función/método debe tener una única responsabilidad.
    -   Utilizar type hints exhaustivamente.
    -   Seguir las convenciones de nombres (`snake_case` para funciones/variables, `PascalCase` para clases).
    -   Docstrings en formato Google Style.

## Story Progress Notes

### Agent Model Used: `Scrum Master: SM`

### Completion Notes List

- Historia 5.1 identificada como la siguiente en la secuencia de Épicas.
- Contexto técnico recopilado de `PRD.md`, `Architecture.md`, `front-end-architecture.md`, `project-structure.md`, `operational-guidelines.md`, `tech-stack.md`, `data-models.md`, y `api-reference.md`.
- Archivo de historia `docs/stories/5.1.story.md` creado con el contenido detallado, incluyendo la historia, criterios de aceptación, tareas/subtareas y guía técnica para el desarrollador.

### Change Log
- 2025-06-02: Creación inicial de la historia 5.1.
