# Story 5.5: Monitoreo Básico del Desempeño por Estrategia en la UI

## Status: Review

## Story

-   As a usuario de UltiBotInversiones
-   I want poder ver en el dashboard un resumen básico del desempeño de cada una de mis estrategias activadas (ej. número de operaciones realizadas, Profit & Loss total generado, y tasa de acierto), diferenciado por modo de operación (Paper Trading y Real)
-   so that pueda evaluar de manera sencilla la efectividad de cada estrategia y tomar decisiones informadas sobre su futura configuración o activación.

## Acceptance Criteria (ACs)

1.  La sección de "Estado del Portafolio" (definida en la Historia 2.4) o, si es más apropiado, una nueva sección dedicada en el dashboard, debe incluir un apartado para el "Desempeño por Estrategia".
2.  Para cada estrategia que haya ejecutado al menos una operación (tanto en modo Paper Trading como en modo Real), el sistema debe mostrar como mínimo la siguiente información:
    *   Nombre de la Estrategia.
    *   Modo de Operación (Paper Trading / Operativa Real Limitada).
    *   Número total de operaciones ejecutadas por esa estrategia en ese modo.
    *   Profit & Loss (P&L) total generado por esa estrategia en ese modo.
    *   Win Rate (porcentaje de operaciones ganadoras sobre el total de operaciones cerradas) para esa estrategia en ese modo.
3.  Esta información de desempeño por estrategia debe actualizarse dinámicamente en la interfaz de usuario, idealmente después de que cada operación cerrada por dicha estrategia sea registrada.
4.  Los datos de desempeño deben ser claramente diferenciados y presentados por separado para el modo Paper Trading y para el modo de Operativa Real Limitada.
5.  El usuario debería poder ver esta información de forma consolidada (sumando todos los modos si tuviera sentido) o tener la opción de filtrar por un modo de operación específico para analizar el desempeño de las estrategias en dicho contexto.

## Dev Technical Guidance

### Componentes Principales Involucrados:

*   **Frontend (UI - PyQt5 - `src/ultibot_ui/`)**:
    *   **Vistas:** Probablemente se modificará `DashboardView` (`src/ultibot_ui/views/` o `src/ultibot_ui/windows/`) para añadir la nueva sección de "Desempeño por Estrategia".
    *   **Widgets:** Se podría crear un nuevo widget reutilizable (ej. `StrategyPerformanceWidget` o `StrategyPerformanceTableView` en `src/ultibot_ui/widgets/`) para mostrar la tabla de desempeño. Este widget podría usar un `QTableView` con un modelo personalizado.
    *   **Modelos de UI:** Si se usa `QTableView`, se necesitará un `QAbstractTableModel` en `src/ultibot_ui/models.py` para manejar los datos de desempeño de las estrategias.
    *   **Cliente API:** Se actualizará `src/ultibot_ui/services/api_client.py` (o su equivalente) para incluir métodos que consuman los nuevos endpoints del backend que proveerán los datos de desempeño.
    *   **Gestión de Estado:** Se seguirán las directrices de `docs/front-end-state-management.md`. Los datos se obtendrán del backend y se usarán señales y slots para actualizar la UI.

*   **Backend (FastAPI - `src/ultibot_backend/`)**:
    *   **API Endpoints:** Se crearán nuevos endpoints en `src/ultibot_backend/api/v1/endpoints/` (ej. en un nuevo `performance.py` o dentro de `portfolio.py` o `strategies.py`). Por ejemplo:
        *   `GET /api/v1/performance/strategies`: Para obtener la lista de desempeño de todas las estrategias. Podría aceptar query params como `?mode=paper` o `?mode=real`.
    *   **Servicios:** Se podría crear un nuevo `PerformanceService` en `src/ultibot_backend/services/` o añadir lógica al `PortfolioService` o `StrategyService`. Este servicio será responsable de:
        *   Consultar los `Trade`s desde `DataPersistenceService`.
        *   Agrupar los trades por `strategyId` y `mode`.
        *   Calcular las métricas: P&L total, número de operaciones, número de operaciones ganadoras.
        *   Calcular el Win Rate (operaciones ganadoras / total de operaciones cerradas).
        *   Obtener los nombres de las estrategias desde `StrategyService` usando los `strategyId`.
    *   **Persistencia de Datos:** El `DataPersistenceService` (`src/ultibot_backend/adapters/persistence_service.py`) será usado para leer los datos de la tabla `trades`.

### Modelos de Datos Clave (ver `docs/data-models.md`):

*   **`Trade`**:
    *   `id`, `userId`, `mode` ('paper' o 'real')
    *   `symbol`, `side`
    *   `strategyId` (para agrupar por estrategia)
    *   `pnl`, `pnlPercentage` (para calcular P&L total y determinar si fue ganadora)
    *   `positionStatus` (para filtrar trades cerrados para el Win Rate)
    *   `closedAt` (para asegurar que el trade está cerrado)
*   **`TradingStrategyConfig`**:
    *   `id` (para enlazar con `Trade.strategyId`)
    *   `configName` (para mostrar el "Nombre de la Estrategia")
*   **`UserConfiguration`**:
    *   No directamente implicada en los cálculos, pero el `userId` es fundamental para filtrar datos.

### Lógica de Cálculo de Métricas (Backend):

*   **P&L Total por Estrategia y Modo:** Suma de `Trade.pnl` para todos los trades cerrados de una `strategyId` específica y un `mode` específico.
*   **Número Total de Operaciones por Estrategia y Modo:** Conteo de todos los trades cerrados para una `strategyId` y `mode`.
*   **Win Rate por Estrategia y Modo:**
    1.  Contar trades ganadores: `COUNT(Trade)` donde `Trade.pnl > 0` (o `pnlPercentage > 0`) para una `strategyId` y `mode`, y `Trade.positionStatus == 'closed'`.
    2.  Contar trades totales cerrados: `COUNT(Trade)` donde `Trade.positionStatus == 'closed'` para la misma `strategyId` y `mode`.
    3.  Win Rate = (Trades Ganadores / Trades Totales Cerrados) * 100. Manejar división por cero si no hay trades cerrados.

### Interacción UI-Backend:

1.  La UI (ej. `DashboardView`) solicitará los datos de desempeño al cargar o al recibir una señal de actualización (ej. después de cerrar un trade).
2.  El `api_client.py` de la UI llamará al nuevo endpoint del backend (ej. `GET /api/v1/performance/strategies`).
3.  El backend (ej. `PerformanceService`) calculará las métricas consultando la base de datos (tabla `trades` y `trading_strategy_configs`).
4.  El backend devolverá una lista de objetos, cada uno representando el desempeño de una estrategia, similar a:
    ```json
    [
      {
        "strategyName": "Scalping BTC Intenso",
        "strategyId": "uuid-scalping-btc",
        "mode": "paper",
        "totalOperations": 50,
        "totalPnl": 125.75,
        "winRate": 60.0 
      },
      {
        "strategyName": "Day Trading ETH Conservador",
        "strategyId": "uuid-daytrading-eth",
        "mode": "real",
        "totalOperations": 5,
        "totalPnl": -25.50,
        "winRate": 20.0
      }
      // ... más estrategias
    ]
    ```
5.  La UI recibirá estos datos y los pasará a su modelo de datos (`QAbstractTableModel`), que a su vez notificará a la `QTableView` para que se redibuje.

### Actualización Dinámica (AC3):

*   **Opción 1 (Ideal - Basada en Eventos):**
    *   Cuando un trade se cierra, el `TradingEngineService` o `PortfolioService` podría emitir un evento (ej. a través de un bus de eventos interno o una señal si están en el mismo proceso).
    *   Un componente en el backend podría escuchar este evento y notificar a la UI (vía WebSockets si están implementados) que los datos de desempeño han cambiado.
    *   La UI, al recibir la notificación WebSocket, re-solicitaría los datos de desempeño.
*   **Opción 2 (Polling o Re-fetch manual):**
    *   La UI podría re-solicitar los datos de desempeño periódicamente (polling, menos eficiente).
    *   O, más pragmático para v1, la UI podría re-solicitar los datos de desempeño después de acciones del usuario que se sabe que afectan el desempeño (ej. después de que el usuario cierra manualmente una posición, o después de recibir una notificación de que un TSL/TP se ejecutó).
*   Para la actualización "idealmente después de que cada operación cerrada por dicha estrategia sea registrada", la Opción 1 es la mejor. Si WebSockets no están en el alcance de v1.0 para este flujo, se podría simular un evento desde el backend a la UI si están en el mismo proceso, o la UI podría re-solicitar los datos después de recibir una notificación de "trade cerrado" (que ya está planeada para la UI vía Historia 2.5).

### Consideraciones Adicionales:

*   **Eficiencia de Consulta:** El backend debe asegurar que las consultas a la base de datos para agregar los datos de trades sean eficientes, especialmente si el número de trades crece. Usar índices en `trades.strategyId`, `trades.mode`, `trades.positionStatus` y `trades.closedAt` será importante.
*   **Manejo de Errores:** La UI y el backend deben manejar casos donde no hay trades para una estrategia, o donde los datos podrían ser inconsistentes.
*   **Filtrado (AC5):** El endpoint del backend debería soportar un parámetro `mode` (`paper`, `real`, o `all`) para permitir el filtrado. La UI proveerá los controles para que el usuario seleccione este filtro.

## Tasks / Subtasks

1.  **Backend:**
    *   [x] Tarea 1.1: Diseñar y crear el(los) nuevo(s) endpoint(s) API en FastAPI (ej. `GET /api/v1/performance/strategies`) para devolver los datos de desempeño por estrategia. (Completada el 2025-06-02 por Agente Stack - Endpoint base creado en `src/ultibot_backend/api/v1/endpoints/performance.py` y router incluido en `main.py`)
        *   [x] Subtarea 1.1.1: Definir los modelos Pydantic para la respuesta de la API. (Completada el 2025-06-02 por Agente Stack - Modelos ya existentes en `src/ultibot_backend/api/v1/models/performance_models.py`)
    *   [x] Tarea 1.2: Implementar la lógica en el servicio del backend (ej. `PerformanceService`) para: (Completada el 2025-06-02 por Agente Stack - Lógica existente en `performance_service.py` verificada y conectada al endpoint)
        *   [x] Subtarea 1.2.1: Obtener los datos de trades cerrados desde `DataPersistenceService`. (Verificada)
        *   [x] Subtarea 1.2.2: Agrupar trades por `strategyId` y `mode`. (Verificada)
        *   [x] Subtarea 1.2.3: Calcular P&L total, número de operaciones, y número de operaciones ganadoras para cada grupo. (Verificada)
        *   [x] Subtarea 1.2.4: Calcular el Win Rate, manejando el caso de cero operaciones cerradas. (Verificada)
        *   [x] Subtarea 1.2.5: Obtener los nombres de las estrategias (`TradingStrategyConfig.configName`) para los `strategyId`. (Verificada)
        *   [x] Subtarea 1.2.6: Formatear los datos para la respuesta de la API. (Verificada)
    *   [x] Tarea 1.3: Escribir pruebas unitarias y de integración para la nueva lógica de servicio y endpoints. (Completada el 2025-06-02 por Agente Stack. Pruebas unitarias para `PerformanceService` en `tests/unit/services/test_performance_service.py` y pruebas de integración para el endpoint `GET /api/v1/performance/strategies` en `tests/integration/api/v1/endpoints/test_performance_endpoints.py` fueron creadas y completadas. Errores de Pylance en `src/ultibot_backend/main.py`, `src/ultibot_backend/adapters/persistence_service.py` y `tests/unit/services/test_trading_engine_story_5_4.py` fueron abordados.)

2.  **Frontend (UI - PyQt5):**
    *   [x] Tarea 2.1: Actualizar/crear el cliente API en la UI (`api_client.py`) para consumir el nuevo endpoint de desempeño de estrategias. (Completada el 2025-06-02 por Agente Front - Método `get_strategy_performance` añadido a `UltiBotAPIClient`)
    *   [x] Tarea 2.2: Diseñar y crear el widget de UI para mostrar el desempeño por estrategia (ej. `StrategyPerformanceTableView` con su `QAbstractTableModel`). (Completada el 2025-06-02 por Agente Front - Creado `src/ultibot_ui/widgets/strategy_performance_table_view.py` con `StrategyPerformanceTableView` y `StrategyPerformanceTableModel`)
        *   [x] Subtarea 2.2.1: Definir las columnas: Nombre Estrategia, Modo, # Ops, P&L Total, Win Rate. (Completada el 2025-06-02 por Agente Front - Columnas definidas en `StrategyPerformanceTableModel`)
        *   [x] Subtarea 2.2.2: Implementar la lógica en el modelo para recibir datos del backend y notificar a la vista. (Completada el 2025-06-02 por Agente Front - Lógica implementada en `StrategyPerformanceTableModel.update_data()` y `StrategyPerformanceTableModel.data()`)
    *   [x] Tarea 2.3: Integrar el nuevo widget en el `DashboardView` (en la sección de "Estado del Portafolio" o una nueva sección). (Completada el 2025-06-02 por Agente Front - `StrategyPerformanceTableView` añadido como pestaña en `DashboardView`)
    *   [x] Tarea 2.4: Implementar la lógica para solicitar los datos de desempeño al backend y actualizar la vista. (Completada el 2025-06-02 por Agente Front - Método `_load_strategy_performance_data` añadido y llamado en `DashboardView`)
    *   [x] Tarea 2.5: Implementar la actualización dinámica de la UI (AC3) - decidir estrategia (evento/WebSocket o re-fetch post-notificación). (Completada el 2025-06-02 por Agente Front - `_load_strategy_performance_data` llamado en `_fetch_new_notifications`, `_handle_trade_confirmed` y `_handle_order_executed`)
    *   [x] Tarea 2.6: Añadir controles de UI para filtrar por modo de operación (Paper, Real, Consolidado) (AC5). (Completada el 2025-06-02 por Agente Stack - Añadido QComboBox en DashboardView para filtrar, conectado a _load_strategy_performance_data)
    *   [x] Tarea 2.7: Asegurar la diferenciación visual clara entre modos (AC4). (Completada el 2025-06-02 por Agente Stack - Añadido coloreado de filas en StrategyPerformanceTableModel según el modo)

3.  **Documentación:**
    *   [x] Tarea 3.1: Actualizar `docs/api-reference.md` con los nuevos endpoints. (Completada el 2025-06-02 por Agente Stack)
    *   [x] Tarea 3.2: Actualizar `docs/front-end-component-guide.md` si se crean nuevos widgets significativos. (Completada el 2025-06-02 por Agente Stack - Añadida documentación para StrategyPerformanceTableView)

## Story Progress Notes
- 2025-06-02 (Agente Stack):
    - Completada Tarea 2.6: Se añadió un QComboBox en `DashboardView` para permitir al usuario filtrar la tabla de desempeño de estrategias por modo ("Todos", "Paper Trading", "Operativa Real"). La lógica de `_load_strategy_performance_data` se actualizó para usar este filtro.
    - Completada Tarea 2.7: Se modificó `StrategyPerformanceTableModel` para añadir un coloreado de fondo a las filas de la tabla de desempeño. Las filas de "Paper Trading" usan un azul claro y las de "Operativa Real" un verde claro, mejorando la diferenciación visual cuando se selecciona el filtro "Todos".
    - Completada Tarea 3.1: Se actualizó `docs/api-reference.md` para incluir la documentación del endpoint `GET /api/v1/performance/strategies`, detallando su propósito, parámetros y estructura de respuesta.
    - Completada Tarea 3.2: Se actualizó `docs/front-end-component-guide.md` añadiendo una entrada para el nuevo componente `StrategyPerformanceTableView` y su modelo asociado `StrategyPerformanceTableModel`.

## Story Draft Checklist Report (2025-06-02 by SM Agent)

**1. GOAL & CONTEXT CLARITY:** PASS
    - Story goal/purpose is clearly stated.
    - Relationship to epic goals is evident.
    - How the story fits into overall system flow is explained.
    - Dependencies on previous stories are identified (Historia 2.4).
    - Business context and value are clear.

**2. TECHNICAL IMPLEMENTATION GUIDANCE:** PASS
    - Key files/modules to create/modify are identified for both frontend and backend.
    - Technologies needed are clear (PyQt5, FastAPI, QTableView).
    - Critical internal APIs/service interactions are described (new GET endpoint, data flow).
    - Necessary data models (`Trade`, `TradingStrategyConfig`) are referenced and their use explained.
    - No new environment variables specific to this story.
    - No exceptions to standard coding patterns noted.

**3. REFERENCE EFFECTIVENESS:** PASS
    - References to `docs/data-models.md`, `docs/front-end-state-management.md`, etc., are relevant.
    - Context for references is provided.
    - Consistent reference format used.

**4. SELF-CONTAINMENT ASSESSMENT:** PASS
    - Core information (ACs, detailed technical guidance, tasks) is included.
    - Assumes developer familiarity with existing project architecture and domain.
    - Logic for metrics (P&L, Win Rate) is explained.
    - Edge cases like division by zero and error handling are mentioned.

**5. TESTING GUIDANCE:** PASS
    - Testing approach for backend (unit, integration) is explicitly mentioned in tasks.
    - Success criteria are implied by ACs.

**VALIDATION RESULT TABLE:**

| Category                             | Status | Issues |
| ------------------------------------ | ------ | ------ |
| 1. Goal & Context Clarity            | PASS   |        |
| 2. Technical Implementation Guidance | PASS   |        |
| 3. Reference Effectiveness           | PASS   |        |
| 4. Self-Containment Assessment       | PASS   |        |
| 5. Testing Guidance                  | PASS   |        |

**Final Assessment:** READY
    - The story provides sufficient context for implementation by a developer agent familiar with the UltiBotInversiones project.
