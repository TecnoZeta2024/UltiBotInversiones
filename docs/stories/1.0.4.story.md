# Story 1.0.4: Puesta en Marcha del Framework de Pruebas Unitarias

## Status: Draft

## Story

- As a Equipo de Desarrollo
- I want Configurar e integrar un framework de pruebas unitarias (ej. PyTest para Python) en el proyecto
- so that Podamos escribir y ejecutar pruebas unitarias desde el inicio del desarrollo, asegurando la calidad del código, facilitando la refactorización y promoviendo buenas prácticas de desarrollo.

## Acceptance Criteria (ACs)

1.  El framework de pruebas unitarias (ej. PyTest) y cualquier librería de apoyo necesaria (ej. pytest-cov para cobertura) se añaden como dependencias de desarrollo en pyproject.toml.
2.  Se establece la estructura de directorios para las pruebas unitarias (ej. tests/unit/) según las convenciones del PRD y futuro Documento de Arquitectura.
3.  Se crea una prueba unitaria de ejemplo simple (ej. para una función de utilidad básica) dentro de la estructura de pruebas, y esta prueba se ejecuta exitosamente.
4.  Se añaden o configuran scripts (ej. en una carpeta scripts/ o mediante comandos de Poetry en pyproject.toml) para ejecutar fácilmente todas las pruebas unitarias.
5.  Se documenta brevemente en el README.md principal o en docs/operational-guidelines.md (si ya existe) cómo ejecutar las pruebas.

## Tasks / Subtasks

- [ ] **Task 1: Añadir dependencias de pruebas a `pyproject.toml` (AC: 1)**
  - [ ] Añadir `pytest` como dependencia de desarrollo.
  - [ ] Añadir `pytest-asyncio` como dependencia de desarrollo.
  - [ ] Añadir `pytest-cov` como dependencia de desarrollo.
  - [ ] Añadir `ruff` como dependencia de desarrollo.
  - [ ] Añadir `pre-commit` como dependencia de desarrollo.
- [ ] **Task 2: Establecer la estructura de directorios de pruebas (AC: 2)**
  - [ ] Crear el directorio `tests/`.
  - [ ] Crear el directorio `tests/unit/`.
  - [ ] Crear el directorio `tests/integration/`.
  - [ ] Crear el directorio `tests/ui/unit/`.
  - [ ] Crear el directorio `tests/e2e/`.
- [ ] **Task 3: Configurar Ruff en `pyproject.toml` (AC: 1, 5)**
  - [ ] Añadir la sección `[tool.ruff]` a `pyproject.toml`.
  - [ ] Configurar las reglas `E, W, F, I, UP, D, B`.
  - [ ] Establecer `line-length = 100`.
- [ ] **Task 4: Configurar `pre-commit hooks` (AC: 5)**
  - [ ] Crear un archivo `.pre-commit-config.yaml` en la raíz del proyecto.
  - [ ] Añadir los hooks para `ruff check --fix` y `ruff format`.
  - [ ] Documentar cómo instalar y usar `pre-commit` en el `README.md` principal o `docs/operational-guidelines.md`.
- [ ] **Task 5: Crear una prueba unitaria de ejemplo (AC: 3)**
  - [ ] Identificar una función de utilidad básica existente o crear una simple en `src/shared/` para probar.
  - [ ] Crear el archivo de prueba correspondiente en `tests/unit/shared/test_utility_function.py`.
  - [ ] Escribir una prueba unitaria simple que se ejecute exitosamente.
  - [ ] Asegurar que la prueba utiliza `unittest.mock` si tiene dependencias externas.
- [ ] **Task 6: Añadir scripts para ejecutar pruebas (AC: 4, 5)**
  - [ ] Añadir un comando a `pyproject.toml` (ej. `poetry run pytest`) o un script en `scripts/` para ejecutar todas las pruebas unitarias.
  - [ ] Documentar cómo ejecutar las pruebas en el `README.md` principal o `docs/operational-guidelines.md`.

## Dev Technical Guidance

*   **Frameworks y Herramientas:** El framework principal de pruebas es `pytest`, con `pytest-asyncio` para soportar código asíncrono. Para mocking y stubbing, se utilizará la biblioteca estándar `unittest.mock`. Para la medición de cobertura de código, se empleará `pytest-cov`.
*   **Calidad de Código:** `Ruff` será la herramienta principal para linting y formateo, configurada en `pyproject.toml` con reglas `E, W, F, I, UP, D, B` y una longitud de línea de 100 caracteres. Es mandatorio configurar `pre-commit hooks` con `ruff check --fix` y `ruff format` para asegurar la consistencia del código antes de cada commit.
*   **Type Safety:** Se exige el uso exhaustivo de `Type Hints` en todas las firmas de funciones, métodos y declaraciones de variables. Los `Pydantic Models` se utilizarán para la validación de datos y la definición de modelos de datos estructurados. Se recomienda el análisis estático de tipos con Ruff (o MyPy si es necesario) para asegurar la corrección de tipos.
*   **Docstrings:** Todas las funciones, clases, métodos y módulos públicos deben incluir docstrings en estilo `Google Style`, explicando su propósito, parámetros, retornos y excepciones.
*   **Pruebas Unitarias:** Deben ser aisladas y enfocarse en la lógica de negocio de los servicios, funciones de utilidad y componentes internos. Todas las dependencias externas (APIs, base de datos, otros servicios) deben ser mockeadas.
*   **Nomenclatura:** Seguir las convenciones de `snake_case` para variables, funciones, métodos y módulos, y `PascalCase` para clases y tipos.

## Story Progress Notes

### Agent Model Used: `SM (Cline)`

### Completion Notes List

- Se ha identificado la siguiente historia para preparación: 1.0.4 - Puesta en Marcha del Framework de Pruebas Unitarias.
- Se ha recopilado y sintetizado el contexto técnico relevante de `PRD.md`, `Architecture.md`, `project-structure.md`, `tech-stack.md` y `operational-guidelines.md`.
- Se ha creado un borrador completo de la historia 1.0.4, incluyendo la historia de usuario, criterios de aceptación, tareas/subtareas detalladas y guía técnica para el desarrollador.

### Change Log
- Creación inicial del borrador de la historia 1.0.4.
